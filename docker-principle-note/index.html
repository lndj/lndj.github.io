<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="referrer" content="no-referrer">

        <!-- Enable responsiveness on mobile devices-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

        <title>Docker 实现原理笔记 | 胡言乱语</title>
<meta property="og:title" content="Docker 实现原理笔记 | 胡言乱语" />
<meta name="twitter:title" content="Docker 实现原理笔记 | 胡言乱语" />

        

        <meta property="og:site_name" content="胡言乱语" />
        <meta property="og:url" content="https:&#x2F;&#x2F;blog.ning.dev" />

        <script src="https://blog.ning.dev/js/instantpage.min.js" type="module" defer></script>


        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://blog.ning.dev/base.css" />
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro&display=swap" rel="stylesheet">
        <link href="https://blog.ning.dev/fontawesome/fontawesome.css" rel="stylesheet">
        <link href="https://blog.ning.dev/fontawesome/brands.css" rel="stylesheet">
        <link href="https://blog.ning.dev/fontawesome/solid.css" rel="stylesheet">

        <link rel='icon' type='image/x-icon' href="https://blog.ning.dev/favicon.ico" />

        

        

    </head>
    <body>
        <a href="#main" class="skip-link p-screen-reader-text">Skip to content</a>
        <header class="l-header">
            <h1 class="c-title p-title"><a href="https:&#x2F;&#x2F;blog.ning.dev" class="p-title__link">胡言乱语</a></h1>
            <p class="p-subtitle">
                胡说八道
            </p>
            </header>

        <main id="main" class="l-main">
            
<article class="p-article">
    <header>
        <h1>Docker 实现原理笔记
</h1>
        <div>
            <div class="c-time">

                <time datetime="2021-04-23">
                    2021-04-23
                </time>
                
                 - (10 min read)
            </div>
        </div>
    </header>
    
    <section id="js-article" class="p-article__body">
        <p>本文简要地记录 Docker 的实现原理。</p>
<p>在 Linux 中，实现容器的边界，主要有两种技术 Cgroups 和 Namespace. Cgroups 用于对运行的容器进行资源的限制，Namespace 则会将容器隔离起来，实现边界。</p>
<p>在宿主机上，查看容器内运行的进程，和在宿主机器上直接运行的进程看起来一般无二，但在容器内部，却看不到容器之外的进程。这样看来，<strong>容器只是一种被限制的了特殊进程而已</strong>。</p>
<span id="continue-reading"></span><h4 id="yi-rong-qi-de-ge-chi-namespace"><strong>一、容器的隔离：Namespace</strong><a class="zola-anchor" href="#yi-rong-qi-de-ge-chi-namespace" aria-label="Anchor link for: yi-rong-qi-de-ge-chi-namespace"><i class="fas fa-link"></i></a> 
</h4>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>docker run --rm -it busybox
</span></code></pre>
<p>进入容器之后执行，查看容器内的进程信息：</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>$ ps
</span><span>PID  USER     TIME  COMMAND
</span><span>1    root     0:00  sh
</span><span>9    root     0:00  ps
</span></code></pre>
<p>可以看到第一个进程的 <code>pid</code> 为 1， 该进程的 <code>pid</code> 为 <code>1747375</code>。其实就是 <code>Linux</code> 的 <code>Namespace</code> 机制。</p>
<p><code>Linux</code> 下，可以使用 <code>clone</code> 来创建一个进程，指定 <code>CLONE_NEWPID</code> 参数，就会创建一个全新的进程空间，函数签名：</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">int</span><span> pid = </span><span style="color:#bf616a;">clone</span><span>(main_function, stack_size, CLONE_NEWPID | SIGCHLD, </span><span style="color:#d08770;">NULL</span><span>); 
</span></code></pre>
<p>下面列出一下相关的参数：</p>
<table><thead><tr><th>分类</th><th>系统调用参数</th><th>相关内核版本</th></tr></thead><tbody>
<tr><td>Mount namespaces</td><td>CLONE_NEWNS</td><td>Linux 2.4.19</td></tr>
<tr><td>UTS namespaces</td><td>CLONE_NEWUTS</td><td>Linux 2.6.19</td></tr>
<tr><td>IPC namespaces</td><td>CLONE_NEWIPC</td><td>Linux 2.6.19</td></tr>
<tr><td>PID namespaces</td><td>CLONE_NEWPID</td><td>Linux 2.6.24</td></tr>
<tr><td>Network namespaces</td><td>CLONE_NEWNET</td><td>始于Linux 2.6.24 完成于 Linux 2.6.29</td></tr>
<tr><td>User namespaces</td><td>CLONE_NEWUSER</td><td>始于 Linux 2.6.23 完成于 Linux 3.8</td></tr>
</tbody></table>
<br />
<blockquote>
<p>PS: <code>Linux</code> 下和进程创建相关的函数： <code>clone</code> <code>fork</code> <code>vfork</code></p>
</blockquote>
<h4 id="er-rong-qi-de-xian-zhi-cgroups"><strong>二、容器的限制：Cgroups</strong><a class="zola-anchor" href="#er-rong-qi-de-xian-zhi-cgroups" aria-label="Anchor link for: er-rong-qi-de-xian-zhi-cgroups"><i class="fas fa-link"></i></a> 
</h4>
<p>上述的 <code>Namespace</code> 技术，实现了容器和宿主机、容器和容器之间的隔离，但是他们之间还是公用系统资源的，如果一个容器占用了大量的系统资源，就会导致其他的容器被影响。<strong><code>Cgroups</code> 技术是 <code>Linux</code> 内核中用于对进程设置资源限制的技术</strong>。</p>
<blockquote>
<p>Linux Cgroups 全称是 Linux Control Group，主要的作用就是限制进程组使用的资源上限，包括 CPU，内存，磁盘，网络带宽。还可以对进程进行优先级设置，审计，挂起和恢复等操作。</p>
</blockquote>
<p>在当前的大多数 <code>Linux</code> 发行版中，我们可以使用 <code>systemctl</code> 来管理 <code>cgroup</code>。</p>
<blockquote>
<p>针对 <code>systemd</code> 的一些使用，参阅： <a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></p>
</blockquote>
<p><code>Systemd</code> 可以管理所有系统资源。不同的资源统称为 <code>Unit</code>（单位）。<code>Unit</code> 分 12 种：</p>
<table><thead><tr><th>类型</th><th>作用</th></tr></thead><tbody>
<tr><td>Service</td><td>一个服务或者一个应用，具体定义在配置文件中</td></tr>
<tr><td>Target</td><td>多个 <code>Unit</code> 构成的一个组</td></tr>
<tr><td>Device</td><td>硬件设备</td></tr>
<tr><td>Mount</td><td>文件系统的挂载点</td></tr>
<tr><td>Automount</td><td>自动挂载点</td></tr>
<tr><td>Path</td><td>文件或路径</td></tr>
<tr><td>Scope</td><td>不是由 <code>Systemd</code> 启动的外部进程</td></tr>
<tr><td>Slice</td><td>进程组</td></tr>
<tr><td>Snapshot</td><td><code>Systemd</code> 快照，可以切回某个快照</td></tr>
<tr><td>Socket</td><td>进程间通信的 <code>socket</code></td></tr>
<tr><td>Swap</td><td><code>swap</code> 文件</td></tr>
<tr><td>Timer</td><td>定时器</td></tr>
</tbody></table>
<p>可以操作，创建一个临时的 <code>cgroup</code>，对其进行资源的限制：</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span> # 创建一个叫 top-test 的服务，在名为 test 的 slice 中运行
</span><span>[root@localhost ~]# systemd-run --unit=top-test --slice=test top -b
</span><span>Running as unit top-test.service.
</span></code></pre>
<p>执行上述命令后，<code>top-test</code> 服务就已经在后台开始运行了。我们可以使用 <code>systemctl-cgls</code> 查看所有的 <code>Cgroups</code>，也可以使用 <code>systemctl status top-test</code> 来查看服务运行状态。</p>
<p>可以使用 <code>cat /proc/{pid}/cgroup</code> 来查看当前的 <code>cgroup</code> 信息。</p>
<p>然后，对其进行资源限制操作：</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>$ systemctl set-property top-test.service CPUShares=800 MemoryLimit=600M
</span></code></pre>
<p>再次去查看 <code>cgroup</code> 信息，会发现在 <code>cpu</code> 和 <code>memory</code> 追加了一些内容。</p>
<p>这时可以在 <code>/sys/fs/cgroup/memory/test.slice</code> 和 <code>/sys/fs/cgroup/cpu/test.slice</code> 目录下，多出了一个叫 <code>top-test.service</code> 的目录。查看其中 <code>toptest.service/cpu.shares</code> 的内容，可以看到 <code>CPU</code> 被限制到了 <code>800</code>。</p>
<p>在 <code>Docker</code> 中，我们也可以做这样限制：</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>$ docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash
</span></code></pre>
<p>关于 <code>docker</code> 具体的限制，可以在 <code>sys/fs/cgroup/cpu/docekr/</code> 等文件夹来查看。</p>
<h4 id="san-rong-qi-de-wen-jian-xi-tong-rong-qi-jing-xiang-rootfs"><strong>三、容器的文件系统：容器镜像 - rootfs</strong><a class="zola-anchor" href="#san-rong-qi-de-wen-jian-xi-tong-rong-qi-jing-xiang-rootfs" aria-label="Anchor link for: san-rong-qi-de-wen-jian-xi-tong-rong-qi-jing-xiang-rootfs"><i class="fas fa-link"></i></a> 
</h4>
<p>在容器内，应该看到完全独立的文件系统，而且不会受到宿主机以及其他容器的影响。这个独立的文件系统，就叫做容器镜像。它还有一个更专业的名字叫 <code>rootfs</code>. <code>rootfs</code> 中包含了一个操作系统所需要的文件，配置和目录，但并不包含系统内核。 因为在 <code>Linux</code> 中，文件和内核是分开存放的，操作系统只有在开启启动时才会加载指定的内核。这也就意味着，<strong>所有的容器都会共享宿主机上操作系统的内核</strong>。</p>
<p>Docker 最早的 slogan 是 <code>Build once, run anywhere</code> ，有了 <code>rootfs</code> ，这个问题就被很好的解决了。因为在镜像内，打包的不仅仅是应用，还有所需要的依赖，都被封装在一起。这就解决了无论是在哪，应用都可以很好的运行的原因。</p>
<p>不光如此，<code>rootfs</code> 还解决了可重用性的问题，想象这个场景，你通过 <code>rootfs</code> 打包了一个包含 <code>java</code> 环境的 <code>centos</code> 镜像，别人需要在容器内跑一个 <code>apache</code> 的服务，那么他是否需要从头开始搭建 <code>java</code> 环境呢？<code>docker</code> 在解决这个问题时，引入了一个叫层的概念，每次针对 <code>rootfs</code> 的修改，都只保存增量的内容，而不是 <code>fork</code> 一个新镜像。</p>
<p>层级的想法，同样来自于 <code>Linux</code>，一个叫 <code>union file system</code> （联合文件系统）。它最主要的功能就是将不同位置的目录联合挂载到同一个目录下。对应在 <code>Docker</code> 里面，不同的环境则使用了不同的联合文件系统。比如 centos7 下最新的版本使用的是 <code>overlay2</code>，而 <code>Ubuntu 16.04</code> 和 <code>Docker CE 18.05</code> 使用的是 <code>AuFS</code>。</p>
<blockquote>
<p>详情参见： <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">Docker storage drivers</a></p>
</blockquote>
<p>可以通过 <code>docker info</code> 来查询使用的存储驱动。</p>
<center>
<image src="/images/overlay_constructs.jpg" />
</center>
<center>Overlay2 整体结构图</center>
<p>Docker 一般的存储位置在 <code>/var/lib/docker</code>，内部存储的结构可以实现了 Docker 的镜像和镜像的分层。</p>
<blockquote>
<p>详细情况 todo</p>
</blockquote>
<h4 id="si-rong-qi-de-wang-luo"><strong>四、容器的网络</strong><a class="zola-anchor" href="#si-rong-qi-de-wang-luo" aria-label="Anchor link for: si-rong-qi-de-wang-luo"><i class="fas fa-link"></i></a> 
</h4>
<p>todo</p>
<h4 id="wu-qi-ta-zong-jie"><strong>五、其他总结</strong><a class="zola-anchor" href="#wu-qi-ta-zong-jie" aria-label="Anchor link for: wu-qi-ta-zong-jie"><i class="fas fa-link"></i></a> 
</h4>
<p><strong>对资源的限制方面：</strong></p>
<p>由于 Docker 内资源的限制通过 <code>Cgroup</code> 实现，而 <code>Cgroup</code> 有很多不完善的地方，比如
对 <code>/proc</code> 的处理问题。进入容器后，执行 <code>top</code> 命令，看到的信息和宿主机是一样的，而不是配置后的容器的数据。（可以通过 <code>lxcfs</code> 修正）。
在运行 <code>java</code> 程序时，给容器内设置的内存为 <code>4g</code>，使用默认的 <code>jvm</code> 配置。而默认的 <code>jvm</code> 读取的内存是宿主机（可能大于 <code>4g</code>），这样就会出现 <code>OOM</code> 的情况。</p>
<p><strong>在隔离性方面：</strong></p>
<p>因为本身上容器就是一种进程，而所有的进程都需要共享一个系统内核，因此：</p>
<ul>
<li>在 <code>Windows</code> 上运行 <code>Linux</code> 容器，或者 <code>Linux</code> 宿主机运行高版本内核的容器就无法实现。</li>
<li>在 <code>Linux</code> 内核中，有许多资源和对象不能 <code>Namespace</code> 化，如时间，比如通过 <code>settimeofday(2)</code> 系统调用 修改时间，整个宿主机的实际都会被修改。</li>
<li>安全的问题，共享宿主机内核的事实，容器暴露出的攻击面更大。</li>
</ul>
<br />
<hr />
<h4 id="can-kao-wen-zhang">参考文章：<a class="zola-anchor" href="#can-kao-wen-zhang" aria-label="Anchor link for: can-kao-wen-zhang"><i class="fas fa-link"></i></a> 
</h4>
<ul>
<li><a href="https://www.cnblogs.com/michael9/p/13039700.html">https://www.cnblogs.com/michael9/p/13039700.html</a></li>
<li><a href="https://coolshell.cn/articles/17010.html">https://coolshell.cn/articles/17010.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li>
</ul>

    </section>
    <footer>
        <nav class="c-pagination p-pagination">
            <div class="c-pagination__ctrl">
                <div class="c-pagination__newer">
                    
                </div>
                <div class="c-pagination__older">
                    
                </div>
            </div>
        </nav>
    </footer>
</article>
        </main>

     
      <footer class="l-footer">
          <p class="p-copyright">
              
              Copyright Ning 2021
          </p>
      </footer>

      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-KP8VE7HCBP"></script>
      <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-KP8VE7HCBP');
      </script> 
      <link rel="stylesheet" href="https://blog.ning.dev/css/katex.min.css">
      <script defer src="https://blog.ning.dev/js/katex.min.js"></script>
      <script defer src="https://blog.ning.dev/js/mathtex-script-type.min.js"></script>
    </body>
</html>
            
